// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import {HandlerStatefulFuzzCatches} from "../../../src/invariant-break/HandlerStatefulFuzzCatches.sol";
import {MockUSDC} from "../../mocks/MockUSDC.sol";
import {YeildERC20} from "../../mocks/YieldERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract AttemptedBreakTest is StdInvariant, Test {
    // Invariant
    // Users must always be able to withdraw the exact deposited amount

    HandlerStatefulFuzzCatches handlerStatefulFuzzCatches;
    MockUSDC mockUSDC;
    YeildERC20 yeildERC20;
    IERC20[] supportedTokens;
    uint256 startingAmount;

    address user = makeAddr("user");

    function setUp() public {
        vm.startPrank(user);

        mockUSDC = new MockUSDC();
        yeildERC20 = new YeildERC20();

        startingAmount = yeildERC20.INITIAL_SUPPLY();

        // yeildERC20 mints automatically for whoever is calling the contract
        // let's mint some mockDSC tokens for the user
        mockUSDC.mint(user, startingAmount);

        vm.stopPrank();

        supportedTokens.push(mockUSDC);
        supportedTokens.push(yeildERC20);

        handlerStatefulFuzzCatches = new HandlerStatefulFuzzCatches(supportedTokens);

        // targetContract
        targetContract(address(handlerStatefulFuzzCatches));
    }

    function test_StartingAmountTheSame() public view {
        uint256 totalSupplyMockUsdc = mockUSDC.totalSupply();
        uint256 totalSupplyyeildERC20 = yeildERC20.totalSupply();

        assertEq(totalSupplyMockUsdc, startingAmount);
        assertEq(totalSupplyyeildERC20, startingAmount);
    }

    // Let's use Stateful Fuzzing without handler
    // If the user deposits and withdraws
    // the amount should be the same
    function statefulFuzz_catchesInvariant_WithoutHandler() public {
        // let's assume fuzzing called `deposit` and `withdraw`
        // which means it `deposited` and `withdrawn` tokens
        // since `depositing` `user` balance will decrease
        // tokens will be transfered to `handlerStatefulFuzzCatches` contract
        // after `withdrawing` user balance will be back to `initalAmount`
        // tokens from `handlerStatefulFuzzCatches` will be given back to the user
        // since foundry does it randomly
        // there may be a chance where last function call was `deposit`

        // therfore we are intentionally calling `withdraw` on behalf of the user
        // since user has withdrawn all amount
        // now `userBalance` should be equal to the `initalAmount`

        vm.startPrank(user);
        handlerStatefulFuzzCatches.withdrawToken(mockUSDC);
        handlerStatefulFuzzCatches.withdrawToken(yeildERC20);
        vm.stopPrank();

        uint256 userMockUSDCBalance = mockUSDC.balanceOf(user);
        uint256 userYeildERC20Balance = yeildERC20.balanceOf(user);

        console2.log("User MockUsdc Balance", userMockUSDCBalance);
        console2.log("User YeildERC Balance", userYeildERC20Balance);

        uint256 handlerFuzzCatchesMockUsdcBalance = mockUSDC.balanceOf(address(handlerStatefulFuzzCatches));
        uint256 handlerFuzzCatchesYeildERC20Balance = yeildERC20.balanceOf(address(handlerStatefulFuzzCatches));

        // since user is withdrawing all amount
        // tokens will be transfered back to the user
        // therfore `handlerFuzzCatches` will have 0 balance
        assertEq(handlerFuzzCatchesMockUsdcBalance, 0);
        assertEq(handlerFuzzCatchesYeildERC20Balance, 0);

        // Since user `withdrawn`
        // User should have the same balance as they started with which is `startingAmount`
        assertEq(userMockUSDCBalance, startingAmount);
        assertEq(userYeildERC20Balance, startingAmount);
    }

    // If we try to run the above test
    // Foundry will call the functions inside `handlerStatefulFuzzCatches` with random Input
    // due to random Input, foundry will try with `unsupported` tokens
    // Therfore all the calls will revert
    // In this case, stateful fuzz test didn't help us
}
