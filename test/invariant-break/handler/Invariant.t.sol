// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test, console2} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import {HandlerStatefulFuzzCatches} from "../../../src/invariant-break/HandlerStatefulFuzzCatches.sol";
import {MockUSDC} from "../../mocks/MockUSDC.sol";
import {YeildERC20} from "../../mocks/YieldERC20.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {Handler} from "./Handler.t.sol";

contract Invariant is StdInvariant, Test {
    // Invariant
    // Users must always be able to withdraw the exact deposited amount

    HandlerStatefulFuzzCatches handlerStatefulFuzzCatches;
    Handler handler;
    MockUSDC mockUSDC;
    YeildERC20 yeildERC20;
    uint256 startingAmount;
    IERC20[] supportedTokens;

    address user = makeAddr("user");

    function setUp() public {
        vm.startPrank(user);

        mockUSDC = new MockUSDC();
        yeildERC20 = new YeildERC20();

        startingAmount = yeildERC20.INITIAL_SUPPLY();

        // yeildERC20 mints automatically for whoever is calling the contract
        // let's mint some mockDSC tokens for the user
        mockUSDC.mint(user, startingAmount);

        vm.stopPrank();

        supportedTokens.push(mockUSDC);
        supportedTokens.push(yeildERC20);

        handlerStatefulFuzzCatches = new HandlerStatefulFuzzCatches(supportedTokens);

        handler = new Handler(handlerStatefulFuzzCatches, mockUSDC, yeildERC20, user);

        // targetContract
        // instead of targetting the `handlerStatefulFuzzCatches`
        // we will target the `handler` which will call the functions in right order
        // we are going to choose specifically the order from the handler
        bytes4[] memory selectors = new bytes4[](4);
        selectors[0] = handler.depositYeildERC20.selector;
        selectors[1] = handler.depositMockUSDC.selector;
        selectors[2] = handler.withdrawYieldERC20.selector;
        selectors[3] = handler.withdrawMockUSDC.selector;

        targetSelector(FuzzSelector({addr: address(handler), selectors: selectors}));
        targetContract(address(handler));
    }

    // Let's use Stateful Fuzzing with handler
    // If the user deposits and withdraws
    // the amount should be the same
    function statefulFuzz_testInvariantBreaks_UsingHandler() public {
        // handler based fuzzing will call `deposit` and then `withdraw`
        // which means it will `deposit` and then `withdrawn` tokens
        // since `depositing` `user` balance will decrease
        // tokens will be transfered to `handlerStatefulFuzzCatches` contract
        // after `withdrawing` user balance will be back to `initalAmount`
        // tokens from `handlerStatefulFuzzCatches` will be given back to the user
        // still foundry will call the functions inside the handler in random order
        // there will be a case where `deposit` will be the finally called function

        // therfore we are intentionally calling `withdraw` on behalf of the user
        // since user has withdrawn all amount
        // now `userBalance` should be equal to the `initalAmount`

        vm.startPrank(user);
        handlerStatefulFuzzCatches.withdrawToken(mockUSDC);
        handlerStatefulFuzzCatches.withdrawToken(yeildERC20);
        vm.stopPrank();

        uint256 userMockUSDCBalance = mockUSDC.balanceOf(user);
        uint256 userYeildERC20Balance = yeildERC20.balanceOf(user);

        console2.log("User MockUsdc Balance", userMockUSDCBalance);
        console2.log("User YeildERC Balance", userYeildERC20Balance);

        uint256 handlerFuzzCatchesMockUsdcBalance = mockUSDC.balanceOf(address(handlerStatefulFuzzCatches));
        uint256 handlerFuzzCatchesYeildERC20Balance = yeildERC20.balanceOf(address(handlerStatefulFuzzCatches));

        // since user is withdrawing all amount
        // tokens will be transfered back to the user
        // therfore `handlerFuzzCatches` will have 0 balance
        assertEq(handlerFuzzCatchesMockUsdcBalance, 0);
        assertEq(handlerFuzzCatchesYeildERC20Balance, 0);

        // Since user `withdrawn`
        // User should have the same balance as they started with which is `startingAmount`
        assertEq(userMockUSDCBalance, startingAmount);
        assertEq(userYeildERC20Balance, startingAmount);
    }

    // [invariant]
    // runs = 64
    // depth = 32
    // fail_on_revert = true

    // fuzz started calling functions in random
    // deposit, withdraw, deposit, withdraw, withdraw yieldERC20...
    // on the 10th time when depositYieldERC20 is called
    // 10% of the amount is sent to the owner
    // which means when user tries to withdraw this yieldERC20
    // userBalance will 10% less than the initial balance
    // therfore our invariant will break
    // because our invariant is
    // users should be always able to `withdraw` the `desposited` amount
}
