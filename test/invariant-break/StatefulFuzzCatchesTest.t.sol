// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import {Test} from "forge-std/Test.sol";
import {StdInvariant} from "forge-std/StdInvariant.sol";
import {StatefulFuzzCatches} from "../../src/invariant-break/StatefulFuzzCatches.sol";

contract StatefulFuzzCatchesTest is StdInvariant, Test {
    StatefulFuzzCatches statefulFuzzCatches;

    function setUp() public {
        statefulFuzzCatches = new StatefulFuzzCatches();
        // targetContract
        targetContract(address(statefulFuzzCatches));
    }

    function test_DoMoreMath_DoesntReturn0(uint128 inputVal) public {
        uint256 returnVal = statefulFuzzCatches.doMoreMathAgain(inputVal);
        assert(returnVal != 0);
    }
    // We wrote a stateless fuzz test
    // It didn't catch the bug

    // To run a stateful Fuzz testing(Open based)
    // include {StdInvariant}
    // add targetContract() in setUp
    // foundry will see this `targetContract` and go into the contract
    // and call the functions randomly

    // for foundry to identify a function to be statefull fuzz
    // we have to include statefulFuzz keyword
    // or we have to include invariant keyword
    // also Invariant test function should have no inputs

    function statefulFuzz_catchesInvariant() public view {
        // uint256 returnVal = statefulFuzzCatches.doMoreMathAgain();
        // assert(returnVal != 0);

        uint256 storedVal = statefulFuzzCatches.storedValue();
        assert(storedVal != 0);
    }

    // earlier we checked for `return` from `doMoreMathAgain` returns 0
    // but we cannot do here
    // uint256 returnVal = statefulFuzzCatches.doMoreMathAgain();
    // since it is an `invariant` we cannot have any inputs
    // therfore we cannot give any inputs to `doMoreMathAgain()`

    // Instead if we look at the actual function
    // contract StatefulFuzzCatches {
    //     uint256 public myValue = 1;
    //     uint256 public storedValue = 100;

    //     /*
    //     * @dev Should never return 0
    //     */
    //     function doMoreMathAgain(uint128 myNumber) public returns (uint256) {
    //         uint256 response = (uint256(myNumber) / 1) + myValue;
    //         storedValue = response;
    //         return response;
    //     }

    //     function changeValue(uint256 newValue) public {
    //         myValue = newValue;
    //     }
    // }

    // `doMoreMathAgain` returns whatever in the `storedValue`
    // therfore if `storedValue` is 0
    // `doMoreMathAgain` will return 0
    // we have to check whether `storedValue` is 0
    // If `storedValue` is 0 then `invariant` would break

    // also set [fail_on_revert] as `false`
    // the reson is, since we are not bounding the input val
    // we can run into `overflow/underflow` error
    // by setting [fail_on_revert] as `false`
    // only when our `assert` failed. It will stop

    //[FAIL. Reason: panic: assertion failed (0x01)]
    //[Sequence]
    //sender=0xAb73C5B62C7E240A5700C0BA6d3E20b4783Addc8 addr=[src/invariant-break/StatefulFuzzCatches.sol:StatefulFuzzCatches]0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f calldata=changeValue(uint256) args=[0]
    //sender=0xbAcD437095C1440D5e2A6C47De84D49cb65730ce addr=[src/invariant-break/StatefulFuzzCatches.sol:StatefulFuzzCatches]0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f calldata=doMoreMathAgain(uint128) args=[0]
    //  statefulFuzz_catchesInvariant() (runs: 128, calls: 4076, reverts: 201)

    // In the above sequence `changeValue(0)` was called therfore `myValue` will be 0
    // Next, `doMoreMathAgain(0)` is called
    //     function doMoreMathAgain(uint128 myNumber) public returns (uint256) {
    //         uint256 response = (uint256(myNumber) / 1) + myValue;
    //         storedValue = response;
    //         return response;
    //     }
    // uint256 response = (uint256(myNumber) / 1) + myValue;
    // `myNumber` is 0 and `myValue` is 0
    // uint256 response = (uint256(0) / 1) + 0;
    // uint256 response = 0
    // since `response` is 0
    // `storedValue` will become 0
    // `Invariant` will break
}
